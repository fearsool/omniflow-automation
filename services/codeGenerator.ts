
import { SystemBlueprint, WorkflowNode, NodeType } from '../types';

// ============================================
// CODE GENERATOR - Blueprint'ten Ã‡alÄ±ÅŸan Kod Ãœret
// ============================================

export type ExportFormat = 'python' | 'nodejs' | 'github-action' | 'dockerfile';

interface GeneratedCode {
  filename: string;
  content: string;
  language: string;
}

// ============================================
// PYTHON GENERATOR
// ============================================
export const generatePythonScript = (blueprint: SystemBlueprint): GeneratedCode[] => {
  const mainScript = `#!/usr/bin/env python3
"""
${blueprint.name}
Auto-generated by OmniFlow Factory
"""

import os
import json
import time
from datetime import datetime

try:
    import google.generativeai as genai
except ImportError:
    print("âŒ google-generativeai yÃ¼klÃ¼ deÄŸil. YÃ¼kleniyor...")
    import subprocess
    subprocess.check_call(['pip', 'install', 'google-generativeai'])
    import google.generativeai as genai

# ============================================
# CONFIGURATION
# ============================================
GEMINI_API_KEY = os.getenv('GEMINI_API_KEY', 'YOUR_API_KEY_HERE')
genai.configure(api_key=GEMINI_API_KEY)

SYSTEM_CONTEXT = """
${blueprint.baseKnowledge || blueprint.description}
"""

# ============================================
# WORKFLOW NODES
# ============================================
${blueprint.nodes.map((node, idx) => `
def node_${idx}_${node.id.replace(/-/g, '_')}(input_data: str) -> str:
    """
    Node: ${node.title}
    Role: ${node.role}
    Type: ${node.type}
    """
    print(f"âš™ï¸ Running: ${node.title}")
    
    model = genai.GenerativeModel('gemini-pro')
    
    prompt = f"""
Role: ${node.role}
Task: ${node.task}
Context: {SYSTEM_CONTEXT}
Input: {input_data}

Execute the task and provide output.
"""
    
    try:
        response = model.generate_content(prompt)
        result = response.text
        print(f"âœ… ${node.title} completed")
        return result
    except Exception as e:
        print(f"âŒ Error in ${node.title}: {e}")
        return f"Error: {e}"
`).join('\n')}

# ============================================
# MAIN EXECUTION
# ============================================
def run_workflow(initial_input: str = "Start"):
    """Execute the complete workflow"""
    print("=" * 50)
    print(f"ðŸš€ Starting: ${blueprint.name}")
    print("=" * 50)
    
    current_output = initial_input
    results = {}
    
${blueprint.nodes.map((node, idx) => `    # Step ${idx + 1}: ${node.title}
    results['${node.id}'] = node_${idx}_${node.id.replace(/-/g, '_')}(current_output)
    current_output = results['${node.id}']
    time.sleep(1)  # Rate limiting
`).join('\n')}
    
    print("\\n" + "=" * 50)
    print("âœ… Workflow completed!")
    print("=" * 50)
    
    return results

if __name__ == "__main__":
    import sys
    initial = sys.argv[1] if len(sys.argv) > 1 else "Workflow baÅŸlatÄ±ldÄ±"
    results = run_workflow(initial)
    
    # Save results
    with open('workflow_results.json', 'w', encoding='utf-8') as f:
        json.dump(results, f, ensure_ascii=False, indent=2)
    print("\\nðŸ“„ Results saved to workflow_results.json")
`;

  const requirements = `# Requirements for ${blueprint.name}
google-generativeai>=0.3.0
python-dotenv>=1.0.0
requests>=2.31.0
`;

  const envExample = `# Environment Variables
GEMINI_API_KEY=your_gemini_api_key_here
`;

  return [
    { filename: 'main.py', content: mainScript, language: 'python' },
    { filename: 'requirements.txt', content: requirements, language: 'text' },
    { filename: '.env.example', content: envExample, language: 'text' }
  ];
};

// ============================================
// GITHUB ACTION GENERATOR
// ============================================
export const generateGitHubAction = (blueprint: SystemBlueprint): GeneratedCode[] => {
  const workflow = `# ${blueprint.name} - GitHub Action
# Auto-generated by OmniFlow Factory

name: ${blueprint.name}

on:
  # Manual trigger
  workflow_dispatch:
    inputs:
      trigger_input:
        description: 'Input for the workflow'
        required: false
        default: 'Scheduled run'
  
  # Scheduled run (her gÃ¼n saat 09:00 UTC)
  schedule:
    - cron: '0 9 * * *'

jobs:
  run-workflow:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          pip install google-generativeai python-dotenv requests

      - name: Run Workflow
        env:
          GEMINI_API_KEY: \${{ secrets.GEMINI_API_KEY }}
        run: |
          python main.py "\${{ github.event.inputs.trigger_input || 'Scheduled run' }}"

      - name: Upload Results
        uses: actions/upload-artifact@v4
        with:
          name: workflow-results
          path: workflow_results.json
          retention-days: 7
`;

  return [
    { filename: '.github/workflows/omniflow.yml', content: workflow, language: 'yaml' }
  ];
};

// ============================================
// NODE.JS SERVER GENERATOR
// ============================================
export const generateNodeServer = (blueprint: SystemBlueprint): GeneratedCode[] => {
  const serverCode = `// ${blueprint.name} - Node.js Server
// Auto-generated by OmniFlow Factory

const express = require('express');
const { GoogleGenerativeAI } = require('@google/generative-ai');
require('dotenv').config();

const app = express();
app.use(express.json());

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

const SYSTEM_CONTEXT = \`
${blueprint.baseKnowledge || blueprint.description}
\`;

// Workflow nodes
const nodes = ${JSON.stringify(blueprint.nodes.map(n => ({
    id: n.id,
    title: n.title,
    role: n.role,
    task: n.task,
    type: n.type
  })), null, 2)};

async function executeNode(node, input) {
  console.log(\`âš™ï¸ Running: \${node.title}\`);
  
  const model = genAI.getGenerativeModel({ model: 'gemini-pro' });
  
  const prompt = \`
Role: \${node.role}
Task: \${node.task}
Context: \${SYSTEM_CONTEXT}
Input: \${input}

Execute and respond.\`;

  try {
    const result = await model.generateContent(prompt);
    return { success: true, output: result.response.text() };
  } catch (err) {
    return { success: false, error: err.message };
  }
}

// API Endpoints
app.post('/run', async (req, res) => {
  const { input = 'Start' } = req.body;
  const results = {};
  let currentOutput = input;

  for (const node of nodes) {
    const result = await executeNode(node, currentOutput);
    results[node.id] = result;
    if (result.success) {
      currentOutput = result.output;
    } else {
      break;
    }
  }

  res.json({ success: true, results });
});

app.get('/health', (req, res) => {
  res.json({ status: 'ok', system: '${blueprint.name}' });
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(\`ðŸš€ ${blueprint.name} running on port \${PORT}\`);
});
`;

  const packageJson = `{
  "name": "${blueprint.name.toLowerCase().replace(/\s+/g, '-')}",
  "version": "1.0.0",
  "description": "Auto-generated by OmniFlow Factory",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js"
  },
  "dependencies": {
    "express": "^4.18.2",
    "@google/generative-ai": "^0.1.3",
    "dotenv": "^16.3.1"
  },
  "devDependencies": {
    "nodemon": "^3.0.1"
  }
}`;

  return [
    { filename: 'server.js', content: serverCode, language: 'javascript' },
    { filename: 'package.json', content: packageJson, language: 'json' }
  ];
};

// ============================================
// DOCKERFILE GENERATOR
// ============================================
export const generateDockerfile = (blueprint: SystemBlueprint): GeneratedCode[] => {
  const dockerfile = `# ${blueprint.name}
# Auto-generated by OmniFlow Factory

FROM node:18-alpine

WORKDIR /app

COPY package*.json ./
RUN npm install --production

COPY . .

ENV NODE_ENV=production
ENV PORT=3000

EXPOSE 3000

CMD ["npm", "start"]
`;

  const dockerCompose = `version: '3.8'
services:
  ${blueprint.name.toLowerCase().replace(/\s+/g, '-')}:
    build: .
    ports:
      - "3000:3000"
    environment:
      - GEMINI_API_KEY=\${GEMINI_API_KEY}
    restart: unless-stopped
`;

  return [
    { filename: 'Dockerfile', content: dockerfile, language: 'dockerfile' },
    { filename: 'docker-compose.yml', content: dockerCompose, language: 'yaml' }
  ];
};

// ============================================
// MASTER EXPORT FUNCTION
// ============================================
export const exportBlueprint = (
  blueprint: SystemBlueprint,
  format: ExportFormat
): GeneratedCode[] => {
  switch (format) {
    case 'python':
      return generatePythonScript(blueprint);
    case 'nodejs':
      return [...generateNodeServer(blueprint), ...generateDockerfile(blueprint)];
    case 'github-action':
      return [...generatePythonScript(blueprint), ...generateGitHubAction(blueprint)];
    case 'dockerfile':
      return [...generateNodeServer(blueprint), ...generateDockerfile(blueprint)];
    default:
      return generatePythonScript(blueprint);
  }
};

// ============================================
// DOWNLOAD HELPER - Individual File Downloads
// ============================================
export const downloadAsZip = async (files: GeneratedCode[], zipName: string) => {
  // Simple approach: download each file individually
  files.forEach((file, index) => {
    setTimeout(() => {
      const blob = new Blob([file.content], { type: 'text/plain;charset=utf-8' });
      const url = URL.createObjectURL(blob);

      const a = document.createElement('a');
      a.href = url;
      a.download = file.filename.split('/').pop() || file.filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);

      URL.revokeObjectURL(url);
    }, index * 300); // Stagger downloads to avoid browser blocking
  });
};

// Single file download helper
export const downloadFile = (content: string, filename: string) => {
  const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
  const url = URL.createObjectURL(blob);

  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);

  URL.revokeObjectURL(url);
};

// ============================================
// COPY TO CLIPBOARD
// ============================================
export const copyToClipboard = async (content: string): Promise<boolean> => {
  try {
    await navigator.clipboard.writeText(content);
    return true;
  } catch {
    return false;
  }
};
