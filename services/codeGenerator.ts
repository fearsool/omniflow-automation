
import { SystemBlueprint, WorkflowNode, NodeType } from '../types';

// ============================================
// CODE GENERATOR - Blueprint'ten Ã‡alÄ±ÅŸan Kod Ãœret
// HuggingFace API kullanÄ±r (ÃœCRETSÄ°Z)
// ============================================

export type ExportFormat = 'python' | 'nodejs' | 'github-action' | 'dockerfile';

interface GeneratedCode {
  filename: string;
  content: string;
  language: string;
}

// ============================================
// PYTHON GENERATOR - HUGGINGFACE VERSION
// ============================================
export const generatePythonScript = (blueprint: SystemBlueprint): GeneratedCode[] => {
  const mainScript = `#!/usr/bin/env python3
"""
${blueprint.name}
Auto-generated by OmniFlow Factory
Uses HuggingFace Inference API (FREE)
"""

import os
import json
import time
import requests
from datetime import datetime

# ============================================
# CONFIGURATION - HUGGINGFACE
# ============================================
HUGGINGFACE_TOKEN = os.getenv('HUGGINGFACE_TOKEN', '')
HF_API_URL = "https://router.huggingface.co/v1/chat/completions"
HF_MODEL = "google/gemma-2-2b-it"  # Free model

SYSTEM_CONTEXT = """
${blueprint.baseKnowledge || blueprint.description}
"""

def call_huggingface(prompt: str) -> str:
    """Call HuggingFace Inference API"""
    if not HUGGINGFACE_TOKEN:
        return "Error: HUGGINGFACE_TOKEN not set"
    
    headers = {
        "Authorization": f"Bearer {HUGGINGFACE_TOKEN}",
        "Content-Type": "application/json"
    }
    
    payload = {
        "model": HF_MODEL,
        "messages": [{"role": "user", "content": prompt}],
        "max_tokens": 1024,
        "temperature": 0.7
    }
    
    try:
        response = requests.post(HF_API_URL, headers=headers, json=payload, timeout=120)
        response.raise_for_status()
        data = response.json()
        
        if "choices" in data and len(data["choices"]) > 0:
            return data["choices"][0]["message"]["content"]
        return str(data)
    except Exception as e:
        return f"Error: {e}"

# ============================================
# WORKFLOW NODES
# ============================================
${blueprint.nodes.map((node, idx) => `
def node_${idx}_${node.id.replace(/-/g, '_')}(input_data: str) -> str:
    """
    Node: ${node.title}
    Role: ${node.role}
    Type: ${node.type}
    """
    print(f"âš™ï¸ Running: ${node.title}")
    
    prompt = f"""
Role: ${node.role}
Task: ${node.task}
Context: {SYSTEM_CONTEXT}
Input: {input_data}

Execute the task and provide detailed output.
"""
    
    result = call_huggingface(prompt)
    print(f"âœ… ${node.title} completed")
    return result
`).join('\n')}

# ============================================
# TELEGRAM NOTIFICATION (Optional)
# ============================================
def send_telegram(message: str):
    bot_token = os.getenv('TELEGRAM_BOT_TOKEN', '')
    chat_id = os.getenv('TELEGRAM_CHAT_ID', '')
    if bot_token and chat_id:
        try:
            url = f"https://api.telegram.org/bot{bot_token}/sendMessage"
            requests.post(url, json={"chat_id": chat_id, "text": message[:4000]})
            print("ðŸ“± Telegram sent")
        except: pass

# ============================================
# MAIN EXECUTION
# ============================================
def run_workflow(initial_input: str = "Start"):
    """Execute the complete workflow"""
    print("=" * 50)
    print(f"ðŸš€ Starting: ${blueprint.name}")
    print(f"ðŸ“… {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print("=" * 50)
    
    current_output = initial_input
    results = {}
    
${blueprint.nodes.map((node, idx) => `    # Step ${idx + 1}: ${node.title}
    results['${node.id}'] = node_${idx}_${node.id.replace(/-/g, '_')}(current_output)
    current_output = results['${node.id}']
    time.sleep(2)  # Rate limiting
`).join('\n')}
    
    print("\\n" + "=" * 50)
    print("âœ… Workflow completed!")
    print("=" * 50)
    
    # Send notification
    send_telegram(f"âœ… ${blueprint.name} tamamlandÄ±!\\n\\n{current_output[:500]}...")
    
    return results

if __name__ == "__main__":
    import sys
    initial = sys.argv[1] if len(sys.argv) > 1 else "Workflow baÅŸlatÄ±ldÄ±"
    results = run_workflow(initial)
    
    # Save results
    output_file = f"results_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
    with open(output_file, 'w', encoding='utf-8') as f:
        json.dump(results, f, ensure_ascii=False, indent=2)
    print(f"\\nðŸ“„ Results saved to {output_file}")
`;

  const requirements = `# Requirements for ${blueprint.name}
requests>=2.31.0
python-dotenv>=1.0.0
`;

  const envExample = `# Environment Variables - HuggingFace (FREE)
HUGGINGFACE_TOKEN=your_huggingface_token_here

# Optional: Telegram notifications
TELEGRAM_BOT_TOKEN=
TELEGRAM_CHAT_ID=
`;

  return [
    { filename: 'main.py', content: mainScript, language: 'python' },
    { filename: 'requirements.txt', content: requirements, language: 'text' },
    { filename: '.env.example', content: envExample, language: 'text' }
  ];
};

// ============================================
// GITHUB ACTION GENERATOR - HUGGINGFACE VERSION
// ============================================
export const generateGitHubAction = (blueprint: SystemBlueprint): GeneratedCode[] => {
  const safeName = blueprint.name.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');

  const workflow = `# ${blueprint.name} - GitHub Action
# Auto-generated by OmniFlow Factory
# Uses HuggingFace API (FREE)

name: "ðŸ¤– ${blueprint.name}"

on:
  workflow_dispatch:
    inputs:
      trigger_input:
        description: 'Input for the workflow'
        required: false
        default: 'Scheduled run'
  
  # Scheduled runs (Turkey time = UTC+3)
  schedule:
    - cron: '0 6 * * *'   # 09:00 TR
    - cron: '0 15 * * *'  # 18:00 TR

env:
  HUGGINGFACE_TOKEN: \${{ secrets.HUGGINGFACE_TOKEN }}
  TELEGRAM_BOT_TOKEN: \${{ secrets.TELEGRAM_BOT_TOKEN }}
  TELEGRAM_CHAT_ID: \${{ secrets.TELEGRAM_CHAT_ID }}

jobs:
  run-workflow:
    runs-on: ubuntu-latest
    
    steps:
      - name: ðŸ“¥ Checkout
        uses: actions/checkout@v4

      - name: ðŸ Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: ðŸ“¦ Install dependencies
        run: |
          pip install requests python-dotenv

      - name: ðŸš€ Run ${blueprint.name}
        run: |
          python main.py "\${{ github.event.inputs.trigger_input || 'Scheduled run' }}"

      - name: ðŸ“¤ Upload Results
        uses: actions/upload-artifact@v4
        with:
          name: ${safeName}-results-\${{ github.run_number }}
          path: results_*.json
          retention-days: 30
`;

  return [
    { filename: `.github/workflows/${safeName}.yml`, content: workflow, language: 'yaml' }
  ];
};

// ============================================
// NODE.JS SERVER GENERATOR - HUGGINGFACE VERSION
// ============================================
export const generateNodeServer = (blueprint: SystemBlueprint): GeneratedCode[] => {
  const serverCode = `// ${blueprint.name} - Node.js Server
// Auto-generated by OmniFlow Factory
// Uses HuggingFace API (FREE)

const express = require('express');
require('dotenv').config();

const app = express();
app.use(express.json());

const HF_TOKEN = process.env.HUGGINGFACE_TOKEN;
const HF_API_URL = "https://router.huggingface.co/v1/chat/completions";
const HF_MODEL = "google/gemma-2-2b-it";

const SYSTEM_CONTEXT = \`
${blueprint.baseKnowledge || blueprint.description}
\`;

// HuggingFace API call
async function callHuggingFace(prompt) {
  const response = await fetch(HF_API_URL, {
    method: 'POST',
    headers: {
      'Authorization': \`Bearer \${HF_TOKEN}\`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      model: HF_MODEL,
      messages: [{ role: 'user', content: prompt }],
      max_tokens: 1024,
      temperature: 0.7
    })
  });
  
  const data = await response.json();
  return data.choices?.[0]?.message?.content || JSON.stringify(data);
}

// Workflow nodes
const nodes = ${JSON.stringify(blueprint.nodes.map(n => ({
    id: n.id,
    title: n.title,
    role: n.role,
    task: n.task,
    type: n.type
  })), null, 2)};

async function executeNode(node, input) {
  console.log(\`âš™ï¸ Running: \${node.title}\`);
  
  const prompt = \`
Role: \${node.role}
Task: \${node.task}
Context: \${SYSTEM_CONTEXT}
Input: \${input}

Execute and respond.\`;

  try {
    const result = await callHuggingFace(prompt);
    return { success: true, output: result };
  } catch (err) {
    return { success: false, error: err.message };
  }
}

// API Endpoints
app.post('/run', async (req, res) => {
  const { input = 'Start' } = req.body;
  const results = {};
  let currentOutput = input;

  for (const node of nodes) {
    const result = await executeNode(node, currentOutput);
    results[node.id] = result;
    if (result.success) {
      currentOutput = result.output;
    } else {
      break;
    }
  }

  res.json({ success: true, results });
});

app.get('/health', (req, res) => {
  res.json({ status: 'ok', system: '${blueprint.name}' });
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(\`ðŸš€ ${blueprint.name} running on port \${PORT}\`);
});
`;

  const packageJson = `{
  "name": "${blueprint.name.toLowerCase().replace(/\s+/g, '-')}",
  "version": "1.0.0",
  "description": "Auto-generated by OmniFlow Factory",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js"
  },
  "dependencies": {
    "express": "^4.18.2",
    "dotenv": "^16.3.1"
  },
  "devDependencies": {
    "nodemon": "^3.0.1"
  }
}`;

  return [
    { filename: 'server.js', content: serverCode, language: 'javascript' },
    { filename: 'package.json', content: packageJson, language: 'json' }
  ];
};

// ============================================
// DOCKERFILE GENERATOR
// ============================================
export const generateDockerfile = (blueprint: SystemBlueprint): GeneratedCode[] => {
  const dockerfile = `# ${blueprint.name}
# Auto-generated by OmniFlow Factory

FROM node:18-alpine

WORKDIR /app

COPY package*.json ./
RUN npm install --production

COPY . .

ENV NODE_ENV=production
ENV PORT=3000

EXPOSE 3000

CMD ["npm", "start"]
`;

  const dockerCompose = `version: '3.8'
services:
  ${blueprint.name.toLowerCase().replace(/\s+/g, '-')}:
    build: .
    ports:
      - "3000:3000"
    environment:
      - HUGGINGFACE_TOKEN=\${HUGGINGFACE_TOKEN}
    restart: unless-stopped
`;

  return [
    { filename: 'Dockerfile', content: dockerfile, language: 'dockerfile' },
    { filename: 'docker-compose.yml', content: dockerCompose, language: 'yaml' }
  ];
};

// ============================================
// MASTER EXPORT FUNCTION
// ============================================
export const exportBlueprint = (
  blueprint: SystemBlueprint,
  format: ExportFormat
): GeneratedCode[] => {
  switch (format) {
    case 'python':
      return generatePythonScript(blueprint);
    case 'nodejs':
      return [...generateNodeServer(blueprint), ...generateDockerfile(blueprint)];
    case 'github-action':
      return [...generatePythonScript(blueprint), ...generateGitHubAction(blueprint)];
    case 'dockerfile':
      return [...generateNodeServer(blueprint), ...generateDockerfile(blueprint)];
    default:
      return generatePythonScript(blueprint);
  }
};

// ============================================
// DOWNLOAD HELPER - Individual File Downloads
// ============================================
export const downloadAsZip = async (files: GeneratedCode[], zipName: string) => {
  files.forEach((file, index) => {
    setTimeout(() => {
      const blob = new Blob([file.content], { type: 'text/plain;charset=utf-8' });
      const url = URL.createObjectURL(blob);

      const a = document.createElement('a');
      a.href = url;
      a.download = file.filename.split('/').pop() || file.filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);

      URL.revokeObjectURL(url);
    }, index * 300);
  });
};

// Single file download helper
export const downloadFile = (content: string, filename: string) => {
  const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
  const url = URL.createObjectURL(blob);

  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);

  URL.revokeObjectURL(url);
};

// ============================================
// COPY TO CLIPBOARD
// ============================================
export const copyToClipboard = async (content: string): Promise<boolean> => {
  try {
    await navigator.clipboard.writeText(content);
    return true;
  } catch {
    return false;
  }
};
